import subprocess
import tempfile
import os
import json
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class StartleftService:
    @staticmethod
    def parse_iac(iac_type: str, iac_content: str, mapping_content: Optional[str] = None) -> dict:
        """
        Uses Startleft to parse Infrastructure as Code (IaC) content into OTM.
        
        Args:
            iac_type: The type of IaC (e.g., 'terraform', 'cloudformation').
            iac_content: The actual content of the IaC file.
            mapping_content: Optional custom mapping file content.
            
        Returns:
            dict: The generated OTM object.
        """
        
        # Create temp files
        # We need to determine the suffix based on iac_type for Startleft to be happy? 
        # Actually Startleft relies on the --iac-type flag mostly, but extension helps.
        suffix = ".tf" if iac_type == "terraform" else ".json" # Simplified
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=suffix) as iac_file:
            iac_file.write(iac_content)
            iac_path = iac_file.name

        mapping_path = None
        if mapping_content:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".yaml") as map_file:
                map_file.write(mapping_content)
                mapping_path = map_file.name
        
        otm_path = iac_path + ".otm"
        
        # Build command
        # startleft parse --iac-type <type> --output-file <out> <in> [--mapping-file <map>]
        cmd = ["startleft", "parse", "--iac-type", iac_type, "--output-file", otm_path, iac_path]
        
        if mapping_path:
            cmd.extend(["--mapping-file", mapping_path])

        try:
            logger.info(f"Running Startleft: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            logger.info(f"Startleft output: {result.stdout}")
            
            if os.path.exists(otm_path):
                with open(otm_path, 'r') as f:
                    otm_data = json.load(f)
                return otm_data
            else:
                # If startleft didn't crash but didn't produce file (rare)
                raise Exception("OTM file not generated by Startleft")
                
        except subprocess.CalledProcessError as e:
            logger.error(f"Startleft failed: {e.stderr}")
            # Clean up error message
            raise Exception(f"Startleft Conversion Failed: {e.stderr}")
            
        finally:
            # Cleanup
            if os.path.exists(iac_path):
                os.remove(iac_path)
            if mapping_path and os.path.exists(mapping_path):
                os.remove(mapping_path)
            if os.path.exists(otm_path):
                os.remove(otm_path)
